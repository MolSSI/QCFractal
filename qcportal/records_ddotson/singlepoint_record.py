from typing import Any, Optional, Union, Dict

import qcelemental as qcel
from pydantic import Field, constr

ObjectId = int
from .record import DriverEnum
from .record import Record, QCSpecification
from .record_utils import register_record


class SinglepointSpecification(QCSpecification):
    pass


class SinglepointRecord(Record):
    """
    User-facing API for accessing data for a single optimization.

    """

    _SpecModel = SinglepointSpecification
    _type = "single"

    class _DataModel(Record._DataModel):
        # Classdata
        _hash_indices = {"driver", "method", "basis", "molecule", "keywords", "program"}

        # Version data
        version: int = Field(1, description="Version of the SinglepointRecord Model which this data was created with.")
        procedure: constr(strip_whitespace=True, regex="single") = Field(
            "single", description='Procedure is fixed as "single" because this is single quantum chemistry result.'
        )

        # Input data
        driver: DriverEnum = Field(..., description=str(DriverEnum.__doc__))
        method: str = Field(..., description="The quantum chemistry method the driver runs with.")
        molecule: ObjectId = Field(
            ..., description="The Id of the molecule in the Database which the result is computed on."
        )
        basis: Optional[str] = Field(
            None,
            description="The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for "
            "methods without basis sets.",
        )
        keywords: Optional[ObjectId] = Field(
            None,
            description="The Id of the :class:`KeywordSet` which was passed into the quantum chemistry program that "
            "performed this calculation.",
        )
        protocols: Optional[qcel.models.results.ResultProtocols] = Field(
            qcel.models.results.ResultProtocols(), description=""
        )

        # Output data
        return_result: Union[float, qcel.models.types.Array[float], Dict[str, Any]] = Field(
            None, description="The primary result of the calculation, output is a function of the specified ``driver``."
        )
        properties: qcel.models.ResultProperties = Field(
            None, description="Additional data and results computed as part of the ``return_result``."
        )
        wavefunction: Optional[Dict[str, Any]] = Field(None, description="Wavefunction data generated by the Result.")
        wavefunction_data_id: Optional[ObjectId] = Field(None, description="The id of the wavefunction")

    @property
    def molecule(self):
        pass


register_record(SinglepointRecord)
