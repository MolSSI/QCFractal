from __future__ import annotations

import logging
import secrets
import bcrypt
from sqlalchemy.exc import IntegrityError
from qcfractal.storage_sockets.models import UserORM, RoleORM

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from qcfractal.storage_sockets.sqlalchemy_socket import SQLAlchemySocket
    from typing import Dict, Optional, Tuple, Any

def _generate_password() -> str:
    """
    Generates a random password e.g. for add_user and modify_user.

    Returns
    -------
    str
        An unhashed random password.
    """
    return secrets.token_urlsafe(32)


class UserSocket:
    def __init__(self, core_socket: SQLAlchemySocket):
        self._core_socket = core_socket
        self._logger = logging.getLogger(__name__)

    def add(self, username: str, password: Optional[str] = None, rolename: str = "read") -> bool:
        """
        Adds a new user. Passwords are stored using bcrypt.

        Parameters
        ----------
        username : str
            New user's username
        password : Optional[str], optional
            The user's password. If None, a new password will be generated.
        rolename: str (default 'user')
            Role name in the database, like user, admin, etc

        Returns
        -------
        bool :
            A Boolean of success flag
        """

        if password is None:
            password = _generate_password()

        success = False
        with self._core_socket.session_scope() as session:
            role = session.query(RoleORM).filter_by(rolename=rolename).first()

            if role is None:
                return False, f"Role {rolename} is not found."

            hashed = bcrypt.hashpw(password.encode("UTF-8"), bcrypt.gensalt(6))
            blob = {"username": username.lower(), "password": hashed, "role_id": role.id}

            try:
                user = UserORM(**blob)
                session.add(user)
                session.commit()
                success = True
            except IntegrityError as err:
                self._logger.warning(str(err))
                session.rollback()

        return success, password

    def verify(self, username: str, password: str) -> Tuple[bool, str, Any]:
        """
        Verifies if a user has the requested permissions or not. Passwords are
        stored and verified using bcrypt.

        Parameters
        ----------
        username : str
            The username to verify
        password : str
            The password associated with the username

        Returns
        --------
            Tuple:
                - success True/False
                - Message: sucess or error msg
                - permissions object (list of allowed/denied actions on resources)
        """

        with self._core_socket.session_scope() as session:
            data = session.query(UserORM).filter_by(username=username.lower()).first()

            if data is None:
                return (False, "User not found.", {})

            try:
                pwcheck = bcrypt.checkpw(password.encode("UTF-8"), data.password)
            except Exception as e:
                self._logger.warning(f"Password check failure, error: {str(e)}")
                self._logger.warning(
                    f"Error likely caused by encryption salt mismatch, potentially fixed by creating a new password for user {username}."
                )
                return (False, "Password decryption failure, please contact your database administrator.")

            if pwcheck is False:
                return (False, "Incorrect password.", {})

            return (True, "Success", data.role_obj.permissions)

    def modify(
            self,
            username: str,
            password: Optional[str] = None,
            reset_password: bool = False,
            rolename: Optional[str] = None,
    ) -> Tuple[bool, str]:
        """
        Alters a user's password, permissions, or both

        Passwords are stored using bcrypt.

        Parameters
        ----------
        username : str
            The username
        password : Optional[str], optional
            The user's new password. If None, the password will not be updated. Excludes reset_password.
        reset_password: bool, optional
            Reset the user's password to a new autogenerated one. The default is False.
        rolename : Optional[str], optional
            Role name in the Role table

        Returns
        -------
        Tuple[bool, str]
            A tuple of (success flag, message)
        """

        if reset_password and password is not None:
            return False, "only one of reset_password and password may be specified"

        username = username.lower()
        with self._core_socket.session_scope() as session:
            data = session.query(UserORM).filter_by(username=username).first()

            if data is None:
                return False, f"User {username} not found."

            blob = {"username": username}

            if rolename is not None:
                role = session.query(RoleORM).filter_by(rolename=rolename).first()

                if role is None:
                    return False, f"Role {rolename} is not found."
                blob["role_id"] = role.id

            if reset_password:
                password = _generate_password()
            if password is not None:
                blob["password"] = bcrypt.hashpw(password.encode("UTF-8"), bcrypt.gensalt(6))

            count = session.query(UserORM).filter_by(username=username).update(blob)
            success = count == 1

        if success:
            return True, None if password is None else f"New password is {password}"
        else:
            return False, f"Failed to modify user {username}"

    def delete(self, username: str) -> bool:
        """Removes a user

        Parameters
        ----------
        username : str
            The username to remove

        Returns
        -------
        bool
            If the operation was successful or not.
        """

        with self._core_socket.session_scope() as session:
            count = session.query(UserORM).filter_by(username=username.lower()).delete(synchronize_session=False)

        return count == 1

    def get_permissions(self, username: str) -> Dict:
        """

        Parameters
        ----------
        username : str
            The username

        Returns
        -------
        permissions (dict)
            Dict of user permissions, or None if user is not found.
        """

        with self._core_socket.session_scope() as session:
            data = session.query(UserORM).filter_by(username=username.lower()).first()
            try:
                ret = data.role_obj.permissions
            except AttributeError:
                ret = None

        return ret
