from __future__ import annotations

import logging
import secrets
import bcrypt
from sqlalchemy.exc import IntegrityError
from qcfractal.storage_sockets.models import UserORM
from qcfractal.storage_sockets.subsockets import RoleSocket
from qcfractal.exceptions import AuthenticationFailure, UserManagementError
from qcfractal.interface.models import UserInfo

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from sqlalchemy.orm.session import Session
    from qcfractal.storage_sockets.sqlalchemy_socket import SQLAlchemySocket
    from typing import Optional, List, Dict, Any


def _generate_password() -> str:
    """
    Generates a random password

    Returns
    -------
    :
        An plain-text random password.
    """
    return secrets.token_urlsafe(16)


class UserSocket:
    def __init__(self, core_socket: SQLAlchemySocket):
        self._core_socket = core_socket
        self._logger = logging.getLogger(__name__)

    @staticmethod
    def _orm_to_model(user: UserORM) -> UserInfo:
        d = user.dict()
        d.pop("id", None)
        d.pop("role_id", None)
        d.pop("password", None)
        d["role"] = user.role_obj.rolename
        return UserInfo(**d)

    def _get_internal(self, session: Session, username: str) -> UserORM:
        """
        Obtain the ORM for a particular user.

        If the user is not found, an exception is raised. The ORM is attached to the given session

        Parameters
        ----------
        session
            SQLAlchemy session to use for querying
        username
            Username to search for

        Returns
        -------
        :
            ORM of the specified user
        """

        username = username.lower()
        user = session.query(UserORM).filter_by(username=username).one_or_none()

        if user is None:
            raise UserManagementError(f"User {username} not found.")

        return user

    def add(self, user_info: UserInfo, password: Optional[str] = None) -> str:
        """
        Adds a new user

        Parameters
        ----------
        user_info
            New user's information
        password
            The user's password. If None, a new password will be generated.

        Returns
        -------
        :
            The password for the user. This is useful if the password is autogenerated
        """

        if self.exists(user_info.username):
            raise UserManagementError(f"User {user_info.username} already exists")

        if password is None or len(password) == 0:
            password = _generate_password()

        # Role is not directly a part of the ORM
        user_dict = user_info.dict(exclude={"role"})

        with self._core_socket.session_scope() as session:
            # Will raise exception if role does not exist
            role = self._core_socket.role._get_internal(session, user_info.role)

            hashed_pw = bcrypt.hashpw(password.encode("UTF-8"), bcrypt.gensalt(6))

            try:
                user = UserORM(**user_dict, role_id=role.id, password=hashed_pw)  # type: ignore
                session.add(user)
                session.commit()
            except IntegrityError:
                raise UserManagementError(f"User {user_info.username} already exists?")

        return password

    def exists(self, username) -> bool:
        """
        Determine if a username already exists
        """

        username = username.lower()
        with self._core_socket.session_scope() as session:
            user = session.query(UserORM).filter_by(username=username).one_or_none()
            return user is not None

    def verify(self, username: str, password: str) -> Dict:
        """
        Verifies a given username and password, returning the users permissions.

        If the user is not found, or is disabled, or the password is incorrect, an exception is raised.

        Parameters
        ----------
        username
            The username to verify
        password
            The password associated with the username

        Returns
        --------
        :
            Permissions available to that user.
        """

        with self._core_socket.session_scope() as session:
            try:
                user = self._get_internal(session, username)
            except UserManagementError as e:
                # Turn missing user into an Authentication error
                raise AuthenticationFailure(str(e))

            if not user.enabled:
                raise AuthenticationFailure(f"User {username} is disabled.")

            try:
                pwcheck = bcrypt.checkpw(password.encode("UTF-8"), user.password)
            except Exception as e:
                self._logger.error(f"Password check failure for user {username}, error: {str(e)}")
                self._logger.error(
                    f"Error likely caused by encryption salt mismatch, potentially fixed by creating a new password for user {username}."
                )
                raise UserManagementError("Password decryption failure, please contact your system administrator.")

            if pwcheck is False:
                raise AuthenticationFailure("Incorrect password.")

            role_model = RoleSocket._role_orm_to_model(user.role_obj)

        return role_model.permissions

    def change_password(
        self,
        username: str,
        password: str,
    ) -> None:
        """
        Alters a user's password

        Parameters
        ----------
        username : str
            The username
        password : Optional[str], optional
            The user's new password. If the password is empty, an exception is raised
        """

        if len(password) == 0:
            raise UserManagementError("Provided password is empty")

        with self._core_socket.session_scope() as session:
            user = self._get_internal(session, username)
            user.password = bcrypt.hashpw(password.encode("UTF-8"), bcrypt.gensalt(6))

    def reset_password(
        self,
        username: str,
    ) -> str:
        """
        Resets a user's password to an autogenerated string. On error, an exception is raised

        Parameters
        ----------
        username
            The username whose password to change

        Returns
        -------
        :
            A string representing the new password
        """

        password = _generate_password()
        with self._core_socket.session_scope() as session:
            user = self._get_internal(session, username)
            user.password = bcrypt.hashpw(password.encode("UTF-8"), bcrypt.gensalt(6))

        return password

    def delete(self, username: str):
        """Removes a user

        This will raise an exception if the user doesn't exist or is being referenced elsewhere in the
        database.

        Parameters
        ----------
        username
            The username to remove
        """

        try:
            with self._core_socket.session_scope() as session:
                user = self._get_internal(session, username)
                session.delete(user)
        except IntegrityError:
            raise UserManagementError("User could not be deleted. Likely it is being referenced somewhere")

    def get_permissions(self, username: str) -> Dict[str, Any]:
        """
        Obtain the permissions of a user.

        If the user does not exist, an exception is raised

        Parameters
        ----------
        username
            The username

        Returns
        -------
        :
            Dict of user permissions
        """

        with self._core_socket.session_scope() as session:
            user = self._get_internal(session, username)
            return user.role_obj.permissions

    def modify(self, user_info: UserInfo, as_admin: bool) -> None:
        """
        Alters a user's information

        The user to modify is taken from the user_info object.

        The user's username or password cannot be changed this way. If `as_admin` is False, then only
        the descriptive changes (email, etc) can be changed. If it is True, then
        the `enabled` and `role` fields can also be changed.

        Parameters
        ----------
        user_info
            The user info to update the database with
        as_admin
            Enable changing sensitive columns (enabled & role)
        """

        with self._core_socket.session_scope() as session:
            user = self._get_internal(session, user_info.username)

            user.fullname = user_info.fullname
            user.organization = user_info.organization
            user.email = user_info.email

            if as_admin is True:
                role = self._core_socket.role._get_internal(session, user_info.role)

                user.enabled = user_info.enabled
                user.role_id = role.id

    def get(self, username) -> UserInfo:
        """
        Obtains information for a user

        Returns all info for a user, except (hashed) password
        """

        with self._core_socket.session_scope() as session:
            user = self._get_internal(session, username)
            return self._orm_to_model(user)

    def list(self) -> List[UserInfo]:
        """
        Get information about all users
        """

        with self._core_socket.session_scope() as session:
            all_users = session.query(UserORM).order_by(UserORM.id.desc()).all()
            return [self._orm_to_model(x) for x in all_users]
